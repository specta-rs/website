---
title: Flight Science
hidden: true
---

This is an outline of what i've been able to achieve with the Flight Science sponsorship.

# Phase 1 (completed)

From 2/12/2025 to 9/01/2026

## General

These things are pretty self-explainatory:
 - General repo maintenance including upgrading to edition 2024.
 - `diagnostic::on_unimplemented` for better errors - [#401](https://github.com/specta-rs/specta/issues/401)
 - Official `geojson` crate integration - [#437](https://github.com/specta-rs/specta/pull/437) - will merge after (#430) allowing you to remove your fork
 - Official `geozero` crate integration - [#436](https://github.com/specta-rs/specta/pull/436) - will merge after (#430) allowing you to remove your fork
 - Heavily reduce the usage of `specta::internal`.
 - Rename `export` to `collect` - [#388](https://github.com/specta-rs/specta/pull/388)
 - `std` feature like Serde has - [#437](https://github.com/specta-rs/specta/pull/437)
 - Specta attribute bug - [#393](https://github.com/specta-rs/specta/issues/393)
 - Migrate tests to `insta` for Snapshot testing - [#434](https://github.com/specta-rs/specta/pull/434)
 - Fixed flood of warnings and Clippy issues when compiling
 - Drop `#[specta(rename_from_path = ...)]` attribute. It was only ever used by PCR as far as I know and undocumented.

Bugs:
 - Typescript header being exported twice [#414](https://github.com/specta-rs/specta/issues/414)
 - Small TS exporter bug - [#231](https://github.com/specta-rs/specta/issues/231)
 - Prevent ctor segfaults if Specta stack overflows when using `export` feature - [#324](https://github.com/specta-rs/specta/issues/324)
 - Fix invalid output from when exporting w/ TS namespaces - [#409](https://github.com/specta-rs/specta/issues/409)

Minor:
 - Remove `specta::json` as it's useless in it's current form and i'm unsure whether it would be possible without major tradeoffs (tracked in [#94](https://github.com/specta-rs/specta/issues/94)) - [bbb9c01](https://github.com/specta-rs/specta/commit/bbb9c019264ff389a4f65feca6b3f4d79f796d62)

## Reference overhaul

I have done a massive refactor of how references work. References are core to Specta as they are how a single type can refer to another type in it's output (Eg. `{ property: TheReferencedType }` contains a property with a reference to`TheReferenceType`).

All of these related changes where merged in a larger PR [#423](https://github.com/specta-rs/specta/pull/423)

### Remove SpectaID

In Specta we need a unique identifier for each type to properly deduplicate them when exporting, so a type can only every show up once in a `TypeCollection`.

One issue in older versions of SpectaID is that types where assigned an identifier in the `specta::Type` macro, but it is also useful to be able to create dynamic types and export them at runtime. My original solution on `main` prior to this refactor was using an `AtomicUsize` stored on the `TypeCollection` and incrementing it to give each runtime type a unique ID.

This causes major DX issues with `TypeCollection` because if it can be `Clone`d then the `Atomic` would reset and potentially issue overlapping identifiers. One potential solution is that you could wrap it the `AtomicUsize` in an `Arc` to allow it to be shared but this introduces issues with which type collection is responsible for a type as they could branch when cloned but still issue duplicate identifiers from that point forward. This is all confusing and something we don't want end-users to have to think about.

I have rebuilt the system to internally use a custom `ArcId` type which hashes the pointer to a heap allocated or static reference. This gives a unique identifier without us needing to uphold the uniqueness guarantees as that's done by the Rust compiler. All references to a type hold the `ArcId` so the ID (pointer) can never be reused until every single reference is dropped, meaning we can't issue overlapping identifiers *ever*. This also allowed us to restore `Clone` on `TypeCollection` without introducing any confusion. Now supporting runtime types is something that just works how you would expect it.

### Drop `DataType::Literal`

In replacing SpectaID I went a step forward and decided to make these identifiers an implementation detail. The main advantage to this is that it removes a user-facing concept simplifying the library and also makes it much harder to abuse Specta's internals.

It does come with some downsides. Primarily that it makes comparision against a type a bit more complicated so to fix this I introduced `Reference::ref_eq` (inspired by [`Arc::ptr_eq`](https://doc.rust-lang.org/stable/std/sync/struct.Arc.html#method.ptr_eq)).

Now that SpectaID is hidden one issue I ran into is that `specta-serde` keeps track of references it has crawled, this way is to prevent it stack overflowing on recursive types, however this was previously expressed as `HashSet<SpectaID>` which is no longer possible. With these changes I decided to make `Reference` implement `Hash` which in tern required making `DataType` implement `Hash` as `Reference` holds a list of generics (Eg. `{ property: MyReference<String> }`, where the generic is the `DataType` returned from `<String as specta::Type>::reference()`). `DataType` never implemented `Hash` due to `DataType::Literal(LiteralType::f64(...))` which is not `Hash` due to `f64: !Hash`.

One unexpected advantage of this change is that because `HashSet<Reference>` hashes the entire `Reference` including the generics, `specta-serde` will process each generic being passed to a referenced type separately which is actually more correct than the previous implementation as for example if the generic is used in a flatten field, the value of the generic would affect whether the type should be rejected or not. This was an awesome thing to fall out of the refactor I didn't even know was a problem.

It's possible supporting const generics will require us to review this decision as a const `f64` might need to be put into the `DataType` enum but for now this is a massive improvement to what we had. I also wonder if because a const `f64` has to come from the compiler (not runtime) we can express it in a different form (maybe `&'static str`) which can be safely hashed as we don't need to support floating-point math on it. However I need to read more about Rust's rules of floating point numbers in const contexts to understand if this is safe or not.

### Opaque references

Sometimes you want to implement `Type` for a Rust-type which has an exporter-specific meaning. For example `Channel` in Tauri doesn't actually mean anything to the Swift exporter, it only means something to the Typescript exporter as it's aware of the Tauri JS runtime which has a Javascript class to represent a `Channel`.

With this I have build a system for opaque references (here is a real-world example for `specta_typescript::Any`):

```rs
pub struct Any<T = ()>(T);

pub(crate) static ANY_REFERENCE: Reference = Reference::opaque_from_sentinel({
    static SENTINEL: () = ();
    &SENTINEL
});

impl<T> Type for Any<T> {
    fn definition(_: &mut TypeCollection) -> DataType {
        // This just be `Reference::opaque()` but it *must* be cloned and identicial on each call.
        // You could have a `OnceLock<Reference>` which is simple but it would require the memory allocated by the `Reference::opaque()` call to exist for the lifetime of the program.
        // Using `Reference::opaque_from_sentinel` doesn't allocate a reference but is also a lot more error prone. Eg. using `const` instead of `static` will break it's invariants.

        DataType::Reference(ANY_REFERENCE.clone())
    }
}
```

Then in the Typescript exporter we do something like:
```rust
fn export_reference(reference: &Reference) -> String {
    // Note: This is a simplification of the real-world. We actually use "exporter references" to implement this (but they are explained in the next section).
    if reference == &ANY_REFERENCE {
        "any".to_string()
    } else {
        format!("{}", reference.name()) // This also handles generics, and more in the real-world implementation.
    }
}
```

In result this allows us to do something like the following:
```rust
#[derive(Type)]
pub struct Something {
    #[specta(type = specta_typescript::Any)]
    pub field: SomeNonSpectaType,
}
```

I am also thinking of moving Tauri Specta and TauRPC to use this for supporting `tauri::Channel` as the `TypeCollection` manipulation we used to do is no longer supported. This solution is much more robust as the exporters can detect unhandled opaque references and give useful errors instead of the manual manipulation causing internal panicking due to broken invariants of `TypeCollection`.

### Exporter references

In Tauri Specta and TauRPC's exporter code they express custom Typescript objects similar to the following:

```rust
format!("{{ some_property: {} }}", specta_typescript::primtives::export(...));
```

Which looks simple in this example but then they want to export Rust documentation comments, deprecated attributes which requires a JSDoc builder.

And then they want to handle cross-file imports for multi-file exporters, and more.

and very quickly your reimplementing half of `specta-typescript` in the downstream framework, but your custom implementation doesn't benefit from the rigor of Specta's tests and is a pain to maintain.

The core reason why these types are usually manually constructed in strings instead of being given to Specta is because they want to export things which can't be expressed by `DataType`. For example Tauri Specta exports something like:

```ts
export const commands = {
  my_command: (...) => TAURI_INVOKE("command", ...)
}
````

a closure and it's runtime code can't be expressed by `specta::DataType` because that would require being able to represent all Typescript syntax ðŸ˜….

So exporter references are the solution I came up with. They look like the following:

```rust
let ts = specta_typescript::Typescript::default();

let mut s = specta::datatype::Struct::named();
for command in commands {
    // Some logic to build up the closure here

    let mut field = specta::datatype::Field::new(self.define(format!("({arguments}) => {body}")).into());
    field.set_deprecated(command.deprecated().cloned());
    field.set_docs(command.docs().clone());
    s = s.field(command.name().to_lower_camel_case(), field);
}

println!("{}", specta_typescript::primitives::inline(self, cfg.types, &s.build())?);
```

The way this works is similar to opaque references where `Typescript` holds a `Vec<(Reference, Cow<'static, str>)>,` and then in `export_reference` we do something like:

```rust
fn export_reference(reference: &Reference) -> String {
    if let Some((_, typescript)) = ts.references.iter().find(|(re, _)| re.ref_eq(r)) {
        s.push_str(typescript);
        return Ok(());
    } else {
        format!("{}", reference.name()) // This also handles generics, and more in the real-world implementation.
    }
}
```

This results of this are:
 - Easier maintaince for TauRPC and Tauri Specta (once they adopt the new API)
 - More reliable due to a single shared implementation across Specta-based frameworks which can be well tested
 - Mostly-support for multi-file exporting without Tauri Specta and TauRPC needing to think about type imports
 - More consistent bindings format (Specta can have a consistent reasonable default for people who disable formatting on that file)
 - Implicit JSDoc support. Eg. `specta_typescript::Typescript` can be rewritten as `specta_typescript::JSDoc` and it should *just work*, no other changes (*unless the runtime injects custom code into the bindings file*)

## Drop `NamedType` and `Flatten`

Both of these were good ideas but i'm not sure they belong in core.

`NamedType` is a nice convience when doing type-map manipulation but I am trying to design newer API's to make that much harder because it breaks assumptions that Specta's core and exporters depend on. I also believe we can provide better ways to achieve the same sort of things (especially in related with the `Reference` overhaul). Closed by [#429](https://github.com/specta-rs/specta/pull/429)

`Flatten` was designed for compile-time validation of whether flattening is valid. Serde don't do this themselves and I think we have kinda figured out why. It's hard to properly tell in all scenarios and with the move to unbake Serde from Specta's core for better separation of concerns this feature is no longer worth it.

Both of these macros where also commonly forgotten when doing a custom `impl Type for T`, so removing them is nice to simplify the core and reduce bugs with Specta. They were commonly implemented incorrectly in Specta's own official crate implementations (ðŸ˜…) which isn't a great sign of a good API.

## Specta Serde is reborn

[#430](https://github.com/specta-rs/specta/pull/430) - incomplete but getting very close

It became clear very early in Specta's development that it can be a very powerful general introspection tool. This is what brought about support for more langauges than just Typescript and it has even be intended to extend to data formats. Although most of the ecosystem use [Serde](https://serde.rs), it's not the only possible option and we had started work on trying to break more of the Serde support out of the Specta core. This is where `specta-serde` started but i've always been hazzy on exactly how this idea was going to be achieved.

This This PR does a massive refactor which moves the handling of Serde attributes from the Specta macro to the runtime `specta-serde` crate opening up the ability for other formats to implement their own userspace support.

The main concept is that when you pass a type with attributes all of them are visible in the `TokenStream` Specta's macros see. For example:

```bash
#[derive(Type, MyMacro)]
pub struct Testing {
    #[my_attribute(something = "abc")]
    pub testing: String,
}
```

With the new Specta system when we create `DataType::Struct` we also include a lowered version of the raw `TokenStream` passed to `my_attribute` on the `Field`. The same is done for enum variant and contrainer attributes. Then the runtime code in `specta-serde`/any userspace implementation can parse the raw-attributes in whatever way it wants and it can tranform the `DataType` before it's given to `specta-typescript` to implement tagging, renames and more.

Supporting multiple formats is cool but how is this generally useful? This enables per-phase attributes.

For example `specta_serde` can expose:
```rust
// This is not an actual API but it shows the idea better and the final API is undecided.

pub fn transform_for_serialize(dt: DataType) -> DataType;

pub fn transform_for_deserialize(dt: DataType) -> DataType;

pub fn transform_for_both(dt: DataType) -> DataType;
```

When paired with Specta Typescript you can export your type and account for attributes which are differently by Serde between `Serialize` and `Deserialize`. In practice this feature is a bit advanced for an average user but my vision is that TauRPC and Tauri Specta will just handle this internally and end-users don't even need to know about it.

<Callout>This PR implements the Specta core support for per-phase attributes but doesn't actually expose the data from the Serde crate at the moment as it's unclear what the correct API is. <br /> <br /> One major concern I have is that if a type is used by the user for both serialization and deserialization it will need to be exported twice in the bindings file which I could see users disliking. I have some ideas to fix this but for now the Specta core support is the main focus, I can iterate on the high-level APIs later.</Callout>

This PR also aims to implement many missing Serde attributes.

#258 & #232 & #332 & #229 & #328 & #332 & #114 & #229 & #402 & #395 & #132 & #130 & #22

This PR should close the following issues:
 - [#258](https://github.com/specta-rs/specta/issues/258)
 - [#232](https://github.com/specta-rs/specta/issues/232)
 - [#332](https://github.com/specta-rs/specta/issues/332)
 - [#229](https://github.com/specta-rs/specta/issues/229)
 - [#328](https://github.com/specta-rs/specta/issues/328)
 - [#114](https://github.com/specta-rs/specta/issues/114)
 - [#402](https://github.com/specta-rs/specta/issues/402)
 - [#395](https://github.com/specta-rs/specta/issues/395)
 - [#132](https://github.com/specta-rs/specta/issues/132)
 - [#130](https://github.com/specta-rs/specta/issues/130)
 - [#22](https://github.com/specta-rs/specta/issues/22)

It also makes progress towards another 5-or-so more but they require more specific work.

One major thing to note with this change is that previously the following would compile:
```rust
#[derive(Specta)]
#[serde(untagged)] // Any `serde` attributes.
enum Testing { ... }
```

but with the new system `serde` attributes are treated as unknown by Specta so the user will be asked by Rust to include `serde::Serialize`. This is great as in a real-world senario if your using a Serde attribute, you will need to Serde runtime on your type.

Another example of this is that previously:
```rust
#[derive(Specta)]
#[specta(untagged)] // Any `serde`-format attributes passed to `specta`
enum Testing { ... }
```

would work as we parsed the arguments from `specta` and `serde` attributes into the same arguments struct. This will fail to compile as now only Specta-specific attributes can be pased to `#[specta(...)]`. This is great as in practice `#[specta(untagged)]` is not processed by `serde::{Serialize, Deserialize}` so this code would have been broken.

Sadly as this PR is a large refactor and new paradigm, I expect some regressions in the short-term but unit testing will help to iron these out. I am likely going to try and upgrade some real-world codebases to get a better idea of the impact on regular library users to see if a codemod or better guidance can be provided.

## JSDoc rework

This is required to upgrade Tauri Specta as it heavily depends on it. JSDoc is also used for the Typescript exporting of the deprecated attribute and comments. The support for exporting doc comments and deprecated attributes on struct fields and enum variants with Typescript is also a little buggy in `main` due to this.

The JSDoc API is still not complete but it's reusing much more of the Typescript exporters code and is now exposed as `specta_typescript::JSDoc` instead of `specta_jsdoc::JSDoc` as it is not worth it when JSDoc needs so many of the Typescript exporters internals (it's literally a `pub struct JSDoc(crate::Typescript);` where `Typescript` has a hidden `jsdoc: bool` field for slightly adjusting the output).

## Incomplete

Things i've started work on but been unable to finish due to technical constraints. I will come back to these once i've had some more time to work/think.

### TauRPC upgrade

I have started upgrading TauRPC to the `main`. This is a little bit of work with some of the breaking changes and with knowledge of some future ones I am going to make i've been trying to take them into account.

With the new "framework references" feature I think we can also simplify the exporter code a heap but this is going to be something for once the idea is proven out in Tauri Specta as I can afford to ship beta Specta APIs inside Tauri Specta as it's me who maintains it.

[#58](https://github.com/MatsDK/TauRPC/pull/58)

### Drop `#[specta::specta]` from core

The whole function handling system is too tied to Tauri Specta, and there has been discussion in the Tauri working group about ideas of a non-macro command system. On top of that it's always been an idea for me to try and hide `#[specta::specta]` under the `#[tauri::command]` macro as having both is bad DX.

I have done up a PR for removing this stuff but it would be a breaking change to the code that is within the Tauri crate so this is going to need to be approached with caution.

Also with the introduction of `Reference::opaque` I also want to change the `Type` implementation for `Channel` which is going to be rough.

This work is generally skewed towards Tauri Specta as TauRPC doesn't use the function macros from my knowledge (it only uses the `tauri::Channel` implementation) but these changes are *major* blockers for the next Specta release going forward.

I came up with a prototype for the minimal changes to Tauri to allow us to drop `specta::specta` from Tauri Specta [here](https://github.com/oscartbeaumont/tauri/commit/5719486dc97a17f90e94d018505eaa31677960c5). These need some more cleanup before I will do an upstream PR but it's promising. I also chatted with Lucas from the Tauri core-team and he seemed to be able to get behind it but i'm not sure if everyone will be thrilled by these changes as they are basically Tauri Specta-specific code in the Tauri code (although a very minimal amount).

This also closes function system related issues as not planned:
 - [#379](https://github.com/specta-rs/specta/issues/379)
 - [#213](https://github.com/specta-rs/specta/issues/213) - leaving open until we have a solution with the next version of the function integration.

[#432](https://github.com/specta-rs/specta/pull/432)

## Phase 2

From 9/01/2026 to 9/01/2026

## General

These things are pretty self-explainatory:
 - Support for [bytes](https://docs.rs/bytes) - [ref](https://github.com/specta-rs/specta/commit/40e77f9e38cf8a6c715f045f44a851a2c890bc3f)
 - Support for renaming the `selection!` struct - [ref](https://github.com/specta-rs/specta/commit/9e2fc59b06fbd89692dc2311c17a938b4b98804d)
 - Finish off and merge runtime attribute handling from phase 1 -[#430](https://github.com/specta-rs/specta/pull/430)
 - Add `TypeCollection::merge` - [ref](https://github.com/specta-rs/specta/commit/ccfd7d760ec3d7c0e5851c4399f1ff60656ce1e3)
 - Make `specta_typescript::primitives::reference` take `Reference` instead of `DataType` for correctness - [ref](https://github.com/specta-rs/specta/commit/862b52e756340b794f929e65f52554197b7908bf)

## References v2

The reference system overhaul that was implemented in Phase 1 was a remarkable improvement but in spending some time thinking of how we can support branded types I noticed that the system still could use some improvements.

One major change is the realisation that references break down into 3 categories:
 - Named static (Eg. `pub struct` with derive `Type`)
 - Named dynamic (Eg. `NamedDataTypeBuilder::new(...).build(...)`)
 - Opaque - A reference to a string in the exporter (usually of raw-Typescript code) (Eg. `specta_typescript::Any`)

The major issues with the current system are:
 - You can't differentiate between a named dynamic and opaque type as they are both `ArcId::Dyanmic`.
 - You can `Reference::get` on an opaque type. This makes no sense because they are always inlined.
 - You can insert an opaque type into the `TypeCollection` due to the shared `ArcId`. This makes no sense because they are always inlined.

We had effectively conflated named dynamic and opaque types as one concept which isn't true in practice.

So to fix this we defined `Reference` to be the following:
 ```rs
pub enum Reference {
    Named(NamedReference),
    Opaque(OpaqueReference),
}

pub struct NamedReference {
    // `ArcId` becomes `NamedId`.
    pub(crate) id: NamedId,
    pub(crate) generics: ...,
    pub(crate) inline: bool,
}

// Technically `dyn Any` is `dyn DynOpaqueReference` but that's too in the weeds for this.
pub struct OpaqueReference(Arc<dyn Any>);
```

With this restructure the benefits we get are:
 - Can no longer insert or get opaque type into `TypeCollection` (Eg. `NamedReference::get` can't be called with an opaque reference)
 - Can no longer access `inline` or `generic` attributes of opaque type as they are on `NamedReference`.
 - Language exporters can detect unhandled opaque references and give a helpful error. (Eg. if you pass `specta_typescript::Any` to the Swift/Go/etc exporter)

Another change is that the previous opaque reference system was structured. Each new `Reference` was a "unique" pointer that had to be carefully cloned to ensure it pointed to the same type. This is what lead to the very unergonomic `Reference::opaque_from_sentinel` API.

With the new implementation:
 - References are nominal (compared by value)
 - References now have a value (`T`) which means they can hold data.

The benifits of this design is that:
 - Enables branded types as we can store the type and brand information on the opaque reference.
 - You can now define a Typescript framework reference without the `Typescript` instance. This is `specta_typescript::define` in the new API.

The value held on the opaque reference is basically stored in an `Arc<Box<dyn Any>>`, however we had to do some special work to make `PartialEq` and `Eq` work.

With this system:
 - `Reference::opaque(5) == Reference::opaque(5)`
 - `Reference::opaque(5) != Reference::opaque(10)`

This works well for all usecases as the previous behavior of `opaque_from_sentinel` can be achieved by implementing an empty struct:

```rust
pub struct Identity;

Reference::opaque(Identity) == Reference::opaque(Identity)
```

One really cool sideeffect of this system is that we can expose `OpaqueReference::type_name` which gives us the full name of the type. This is great because langauge exporter can show errors which give the user much more information as it can point to the exact source of the type.

In the old system we had something like:

```rust
pub struct Any<T = ()>(T);

pub(crate) static ANY_REFERENCE: Reference = Reference::opaque_from_sentinel({
    static SENTINEL: () = ();
    &SENTINEL
});

impl<T> Type for Any<T> {
    fn definition(_: &mut TypeCollection) -> DataType {
        // This just be `Reference::opaque()` but it *must* be cloned and identicial on each call.
        // You could have a `OnceLock<Reference>` which is simple but it would require the memory allocated by the `Reference::opaque()` call to exist for the lifetime of the program.
        // Using `Reference::opaque_from_sentinel` doesn't allocate a reference but is also a lot more error prone. Eg. using `const` instead of `static` will break it's invariants.

        DataType::Reference(ANY_REFERENCE.clone())
    }
}
```

Whereas in the new system we can do something like:

```rust
use specta_typescript::define;

pub struct Any<T = ()>(T);

impl<T> Type for Any<T> {
    fn definition(_: &mut TypeCollection) -> DataType {
        DataType::Reference(define("any"))
    }
}
```

Much simplier. To explain in some more detail:

`define` is implemented as such:

```rust
#[derive(PartialEq, Eq, Hash)]
pub(crate) struct Define(pub(crate) Cow<'static, str>);

pub fn define(raw: impl Into<Cow<'static, str>>) -> Reference {
    Reference::opaque(Define(raw.into()))
}
```

and then in the Typescript exporter reference generation logic we do:

```rust
fn reference_opaque_dt(
    s: &mut String,
    exporter: &Exporter,
    types: &TypeCollection,
    r: &OpaqueReference,
) -> Result<(), Error> {
    if let Some(def) = r.downcast_ref::<opaque::Define>() {
        s.push_str(&def.0); // pushes the Typescript straight to the output
        return Ok(());
    }

    ...
}
```

### Branded types prototype

This is unfinished but I have a working prototype of Typescript branded types. If you haven't come across branded types before, [checkout this Effect article](https://effect.website/docs/code-style/branded-types/).

Currently the API looks like the following:

```rust
use specta_typescript::branded;

branded!(#[derive(Default)] struct AccountId(String) as "accountId");

#[derive(Type)]
pub struct Account {
    id: AccountId,
    name: String,
}
```

<Callout title="This API is experimental" type="warning">
    I am happy with the low-level implementation ontop of opaque references but I quickly threw together the user-facing API for testing.

    I think the `branded` macro_rules will probably stay but I can't say for sure and whether it's syntax will change or not.
</Callout>

The API:
 - Can only have a tuple struct with a single field which is inherently transparent (Eg. we export as `String` not `AccountId` in the previous example)
 - Works with generics
 - Allows omitting `as "brand"` and it will fallback to the struct ident (Eg. `AccountId` in the previous example)

The way this is implemented under the hood is using an opaque reference:

[The implementation is here](https://github.com/specta-rs/specta/blob/main/specta-typescript/src/branded.rs) but it looks remarkably similar to `define` which is shown above.

## Review Tauri integration

Currently we have a small amount of Specta code within Tauri. This is what powers the integration with Tauri Specta and TauRPC. I had a look at each part of it to see if we can improve it.

### Reexports

Tauri has a built-in Specta feature to provide implementations for `Type` and `specta::function::*`. These were required to workaround the fact that Tauri v1 and v2 couldn't exist as a dependency within the same Cargo workspace ([explained here](https://github.com/specta-rs/tauri2)) which was causing a massive issue in Tauri Specta. These implementations being upstreamed meant this was not going to be a problem for a potential Tauri v3 or later.

The downside with this is that Tauri is a semver-stable library so it's dependency on Specta needs to be taken carefully to ensure a downstream user doesn't get their project broken by a `cargo update`.

I was able to remove `pub use datatype::DataType;` from Specta's root as Tauri doesn't depend on this and it was just left in caution.

Long term sadly, we have to keep `pub type TypeMap = TypeCollection;` as Tauri imports from `function::TypeMap` and it would be breaking to remove.

### Channel

This is used by both Tauri Specta and TauRPC to ensure a `tauri::ipc::Channel` in a command can be typed correctly. This is more complicated than a regular type because we need to import `Channel` from `@tauri-apps/api/core` as it's not a type Specta creates.

Under the hood the way this worked in the past was we did:

```rs
self.types
    .remove(<tauri::ipc::Channel<()> as specta::NamedType>::sid()); // `NamedType` changed a lot across versions but concept is the same
```

and then we always included the `import { Channel } from "@tauri-apps/api/core";` in the Typescript file. This was a great hack to get this feature working but is not something great as a long term solution. This hack meant that the `Channel` import would always exist in the bindings file, even when not used and also we broke an invariant of Specta system, that a reference can't exist without a type being created in the `TypeCollection`.

With the changes on `main` I had previously removed the `TypeCollection::remove` method which renders this hack impossible so it was time to finally figure out a proper solution.

Given i've been working with opaque references my first thought was to try them. What if we had something like the following in Tauri:

```rust
impl<T> Type for Channel<T> {
    fn definition(_: &mut TypeCollection) -> DataType {
        pub struct Channel;
        DataType::Reference(Reference::opaque(Channel))
    }
}
```

This makes heaps of sense but how does the opaque reference becomes some Typescript code?

Well we get two options:
 - Make `tauri` depend on `specta_typescript`, or
 - Make `specta_typescript` depend on `tauri`

We either need to call `Channel::definition` in the `specta_typescript` so we can `if incoming_ref == get_ref(Channel::definition()) { ... }` to branch on the channel or we need to use `specta_typescript::define` in Tauri. Neither of these are a viable option for semver reasons so we need to look somewhere else.

Using opaque references would also require a major breaking change in Tauri which is would not be viable. This systems means we only need this small upstream change ([tauri-apps/tauri#14812](https://github.com/tauri-apps/tauri/pull/14812))  to drop `#[specta(rename = ...)]` from `Channel`.

Instead inside of Specta we patch over the Tauri channel type with the following taken from `named.rs`:

```rust
// Called by `Type` macro inside the `fn definition` function.
fn init_with_sentinel(...) {
    let ndt: NamedDataType = ...;

    // We patch the Tauri `Type` implementation.
    if ndt.name() == "TAURI_CHANNEL" && ndt.module_path().starts_with("tauri::") {
        // This produces `never`.
        // It's expected a framework replaces this with it's own setup.
        ndt.inner = Infallible::definition(types);

        // This ensures that we never create a `export type Channel`,
        // instead the definition gets inlined into each callsite.
        ndt.inline = true;
    }
}
```

These two changes mean that any `Channel`'s export as `never` by default. Well how do we transform this into a `Channel` import? This is where Tauri Specta/TauRPC come in with the following:

```rust
use specta_typescript::define;

let types: TypeCollection = ...;

// We replace the `never` with Typescript string `Channel`
types.iter_mut(|ndt| {
    if ndt.name() == "TAURI_CHANNEL" && ndt.module_path().starts_with("tauri::") {
        *ndt.ty_mut() = DataType::Reference(define("Channel"));
    }
});

// We can also then detect when the `Channel` import is required by crawling the `DataType` for each command.
let is_channel_used = commands.iter().any(|command| {
    // Check if any argument is a Channel
    command.args().iter().any(|(_, dt)| is_channel_type(dt, &cfg.types))
        // Check if result contains a Channel
        || command.result().is_none_or(|result| match result {
            FunctionReturnType::Value(dt) => is_channel_type(dt, &cfg.types),
            FunctionReturnType::Result(ok, err) =>
                is_channel_type(ok, &cfg.types) || is_channel_type(err, &cfg.types),
        })
});

if is_channel_used {
    output.push_str("import { Channel } from \"@tauri-apps/api/core\"");
}
```

This implementation works but in the bindings file you end up with the following unexpected type:

```rust
export type Channel<TSend> = Channel;
```

This is because Specta generates a type for every named type. If you think about it through the `Channel` named type is inlined. This means the exporter will never generate `{ property: Channel<T> }` it will always generate it's type inline like `{ property: never }`. Given this we know it's impossible for any inline type to be referenced and therefore it's not necessary to export them.

This also required making some tweaks to the `Reference` system. Namely that for this to work we must ensure all named references are inlined if the container is inlined. This was already how it was intended to work but the implementation overlooked a couple of edgecases which needed fixing.

### Function implementations

Long term I want to remove Specta's function handling system (`specta::function::*` & `specta::specta` macro) as it was a good idea in theory but i'm not sure it's something that belongs in Specta's core anymore. The currently implementation is heavily tied to the way `#[tauri::command]` works and to fix some remaining bugs in Tauri Specta this is going to get worse.

I built a prototype of this in a fresh crate and started work on a PR to Tauri but it's incomplete.

At a core level if Tauri exposes:
 - the names of the command arguments
 - the doc comments on a command
 - the deprecated attribute of a command

Tauri Specta could work without requiring the `#[specta::specta]` macro and without stabilising the `specta::function::*` and `specta::specta` macro.

Although these changes are for Tauri Specta they are being done under the higher-level goal of reducing the API surface of Specta for better maintainability & reliability.

<Callout title="Incomplete work" type="warning">
    This work on removing the function stuff from the core is incomplete but being documented as I did more research into it's viability.
</Callout>

### Restructure `specta_typescript`

Specta Typescript has been in need of a lot of work to properly support frameworks like Tauri Specta and TauRPC with the new `Layout` system for multi-file exporting so we were in need of a major refactor.

Previously the `JSDoc` exporter was defined something like:

```rust
pub struct JSDoc(Typescript);

impl Default for JSDoc {
    fn default() -> Self {
        let ts = Typescript::default();
        ts.jsdoc = true
        ts
    }
}
```

now we have refactored so that both `JSDoc` and `Typescript` wrap an `Exporter` struct which contains the implementation. This is useful because:
 - You can erase a `Typescript` or `JSDoc` into an `Exporter` so more of your export code can be shared.
 - It's clearer how conversions work. Eg. What does converting from a `JSDoc` to a `Typescript` do, should it disable JSDoc or not. Previously it did but that mean you couldn't get a exporter-type which spanned both languages without a generic + trait system.

This also allowed moving some of the more low-level framework APIs from `Typescript` to `Exporter` making them harder to use. The user must explicitly `Export::from(Typescript::default())` to set certain parameter.

The logic in the `Exporter` was rewritten to:
 - be more reliable
 - for `Layout::Files` generate the files before any FS operations so any thrown errors don't leave an invalid state on disk
 - for `Layout::Files` properly cleanup leftover files in the directory (even when converting between `.ts` and `.js` extensions)
 - Check for duplicate type names, modules or import for each logical scope (whether that be a file or a namespace). The previous system only checked for duplicates on `Layout::FlatFile` which is wrong.
 - Handle `Reference::requires_reference` to omit creating a named export for any types which are container inlined (Eg. Tauri Channel) and hence will never be referenced.
 - Factor the code out into helper functions, allowing for more code reuse.
 - Omit creating files or namespaces if the module is empty
 - Restructured `Layout::Namespace` to properly create references across namespaces without shadowing issues.
 - Ensure a consistent type export order in `Layout::Files` or `Layout::Namespaces`. Copied from the `TypeCollection::into_sorted_iter`
 - Convert `framework_runtime` into a function which takes in `FrameworkExporter` giving access to the `TypeCollection` and a way of interspersing user types within the runtime code (instead of it being appended which is the default).
 - When doing `Layout::Files` create `export * as module_name from "./module_name"` exports so that you can easily go `module.module.Type` in Typescript
 - wip: progress towards fixing imports across files with `Layout::Files`

 This has been a lot of work but it is going to be a huge pay of for the ecosystem. Previously a lot of this logic in various forms was in Specta, Tauri Specta and TauRPC. By formalising it and centralising it within Specta all of the frameworks can hand off the maintenance burden to a single well-tested implementation in Specta.

### Upgrade frameworks

Tauri Specta:
 - Rewrite exporting logic around `Exporter`
 - Using `framework_runtime` so that layouts are supported
 - Making `tauri::ipc::Channel` work with the new integration.
 - Improve the bindings format to be much cleaner and hand off more of it's generation to Specta using the new opaque references system
 - Only include parts of the file as required. Eg. imports or runtime functions are detected and omitted if not used.
 - Rethinking error handling based on Typescript type-inference to allow support for EffectTS, neverthrow and other similar methods. We are going to port this to TauRPC in a future phase!

TauRPC: Sadly ran out of time to complete this. Will be first thing in next phase but should be fairly smooth now that Tauri Specta has proven out the flexibility of the new APIs.

Work on Tauri Specta has allowed me to experiment as Tauri Specta has always been a really good testing ground for experimental Specta APIs due to it's design.

### Restucture tests

I rebuilt the testing harness around snapshot testing and testing all permutations of `inline`, `export`, `reference` and also using all `SerdeMode`'s along with testing `export` and `export_to`. All tests run and build up snapshot files using [insta](https://insta.rs).

The move to snapshot testing was to ease manitaince burdon as Typescript types can be represented in many ways which are all valid due to formatting so snapshot testing allows formatting changes to easily be updated across multiple tests.

The new harness also defines types to test separately from the tests themselves. This makes it easy for us to run each type through a heap of permutations of settings without needing a massive amount of code in the tests.

I also spent some time rename and removing clearly duplicate tests.

<Callout title="Work is incomplete" type="warning">
    I have built the new harness and migrated tests however the snapshots being generated do contain bugs. I need to spend some time ensuring the snapshots for things that were previously untested are correct.
</Callout>

## Phase 3

From 9/01/2026 to ...

### Planned:

Release blockers for (`specta-rc.23`):
 - Upgrade TauRPC
 - [tauri-apps/tauri#14812](https://github.com/tauri-apps/tauri/pull/14812).
 - Stability

Known stability issues/bugs:
 - `thiserror` compaibility is broken
 - All crates don't compile with all features enabled
 - Avoid creating a namespace if itâ€™s empty (like we did for `Layout::Files`)
 - `Exporter` shouldnâ€™t need to call `typedef_internal`, it should be implicitly done in `export_internal`?
 - `import * as framework` import is hardcoded into Specta but this only works for `specta-typescript/examples/framework.rs`
    - Cleanup references instead of `framework.current_module.nested.type` do `nested.type` if possible
    - Also fix duplicate type name scope logic around whatever the import becomes.
    - Also only add the import if it's required (Eg. a reference is created in that file)
 - When the `framework_runtime` isn't defined the module reexports get shallowed.
 - Namespaces should be formatted to the correct depth with tabs
 - JSDoc issues:
   - Exporting comments and deprecated is broken (can reproduce on `events` and `commands` in Tauri Specta)
   - should merge all `@typedef`â€™s into a single comment
   - build JSDoc param building into Specta
   - `import type` and `export { module };` are broken
   - Fix extra `\n` on user types
 - Gracefully error out on dangling named reference in Typescript (instead of `panic`)
 - Fix memory leak in Typescript primitives
 - Fix container inline which is breaking `selection!` macro.

Testing:
 - Finish migration to new snapshot testing harness
 - Cleanup default formatting of bindings (before we finish overhaulling testing cause it'll break all of them)
 - https://github.com/specta-rs/specta/issues/356

 - Test empty module path with everything (mainly namespaces and files)
 - Test virtual `module_path` logic better
 - Unit test empty module path and it not creating a file or creating an empty namespace
 - Unit test exporter logic for file system creation and possible edge cases (directory where a file needs to go, etc)

Real-world testing:
 - Upgrade Cap/Spacedrive/FlightScience codebases to see how the new macros go.
 - Chat with Brendan about any bugs he is finding in OpenCode.

### Strech

Core work:
- Tauri Bigint support  - How does `Channel` work in Tauri core? Could the same system be abused for BigInt support?
- Nauanced types prototype
- Errors as strings or serialize
- Figure out how to make `alias` properly exported to Typescript as a descriminated union. This is a bit of a remaining question in how `specta-serde` needs to work.
- `impl Type for Result<T, E>` (likely blocked on removal of `#[specta::specta]`)
- Figure out how `MaybeUndefined` could be represented with Specta/`DataType`.
- Documentation overhaul (including documentation for all-possible attributes that we support)
- Potentially look at upstreaming [this](https://github.com/fltsci/plugins-workspace/tree/add-specta-to-updater) into Tauri Plugins repo as they do already have Specta in that repo.

Specta Serde:
 - Better split with Specta Typescript
 - Multi-phase exporting working

Branded types high-level API:
 - Change default brand structure to `{ _brand: "myBrand" }`
 - Allow using brands from 3rd party crates like EffectTS
 - Runtime helpers for constructing them
