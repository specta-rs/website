---
title: Flight Science
hidden: true
---

This is an outline of what i've been able to achieve with the Flight Science sponsorship.

# Phase 1 (completed)

From 2/12/2025 to 9/01/2026

## General

These things are pretty self-explainatory:
 - General repo maintenance including upgrading to edition 2024.
 - `diagnostic::on_unimplemented` for better errors - [#401](https://github.com/specta-rs/specta/issues/401)
 - Official `geojson` crate integration - [#437](https://github.com/specta-rs/specta/pull/437) - will merge after (#430) allowing you to remove your fork
 - Official `geozero` crate integration - [#436](https://github.com/specta-rs/specta/pull/436) - will merge after (#430) allowing you to remove your fork
 - Heavily reduce the usage of `specta::internal`.
 - Rename `export` to `collect` - [#388](https://github.com/specta-rs/specta/pull/388)
 - `std` feature like Serde has - [#437](https://github.com/specta-rs/specta/pull/437)
 - Specta attribute bug - [#393](https://github.com/specta-rs/specta/issues/393)
 - Migrate tests to `insta` for Snapshot testing - [#434](https://github.com/specta-rs/specta/pull/434)
 - Fixed flood of warnings and Clippy issues when compiling
 - Drop `#[specta(rename_from_path = ...)]` attribute. It was only ever used by PCR as far as I know and undocumented.

Bugs:
 - Typescript header being exported twice [#414](https://github.com/specta-rs/specta/issues/414)
 - Small TS exporter bug - [#231](https://github.com/specta-rs/specta/issues/231)
 - Prevent ctor segfaults if Specta stack overflows when using `export` feature - [#324](https://github.com/specta-rs/specta/issues/324)
 - Fix invalid output from when exporting w/ TS namespaces - [#409](https://github.com/specta-rs/specta/issues/409)

Minor:
 - Remove `specta::json` as it's useless in it's current form and i'm unsure whether it would be possible without major tradeoffs (tracked in [#94](https://github.com/specta-rs/specta/issues/94)) - [bbb9c01](https://github.com/specta-rs/specta/commit/bbb9c019264ff389a4f65feca6b3f4d79f796d62)

## Reference overhaul

I have done a massive refactor of how references work. References are core to Specta as they are how a single type can refer to another type in it's output (Eg. `{ property: TheReferencedType }` contains a property with a reference to`TheReferenceType`).

All of these related changes where merged in a larger PR [#423](https://github.com/specta-rs/specta/pull/423)

### Remove SpectaID

In Specta we need a unique identifier for each type to properly deduplicate them when exporting, so a type can only every show up once in a `TypeCollection`.

One issue in older versions of SpectaID is that types where assigned an identifier in the `specta::Type` macro, but it is also useful to be able to create dynamic types and export them at runtime. My original solution on `main` prior to this refactor was using an `AtomicUsize` stored on the `TypeCollection` and incrementing it to give each runtime type a unique ID.

This causes major DX issues with `TypeCollection` because if it can be `Clone`d then the `Atomic` would reset and potentially issue overlapping identifiers. One potential solution is that you could wrap it the `AtomicUsize` in an `Arc` to allow it to be shared but this introduces issues with which type collection is responsible for a type as they could branch when cloned but still issue duplicate identifiers from that point forward. This is all confusing and something we don't want end-users to have to think about.

I have rebuilt the system to internally use a custom `ArcId` type which hashes the pointer to a heap allocated or static reference. This gives a unique identifier without us needing to uphold the uniqueness guarantees as that's done by the Rust compiler. All references to a type hold the `ArcId` so the ID (pointer) can never be reused until every single reference is dropped, meaning we can't issue overlapping identifiers *ever*. This also allowed us to restore `Clone` on `TypeCollection` without introducing any confusion. Now supporting runtime types is something that just works how you would expect it.

### Drop `DataType::Literal`

In replacing SpectaID I went a step forward and decided to make these identifiers an implementation detail. The main advantage to this is that it removes a user-facing concept simplifying the library and also makes it much harder to abuse Specta's internals.

It does come with some downsides. Primarily that it makes comparision against a type a bit more complicated so to fix this I introduced `Reference::ref_eq` (inspired by [`Arc::ptr_eq`](https://doc.rust-lang.org/stable/std/sync/struct.Arc.html#method.ptr_eq)).

Now that SpectaID is hidden one issue I ran into is that `specta-serde` keeps track of references it has crawled, this way is to prevent it stack overflowing on recursive types, however this was previously expressed as `HashSet<SpectaID>` which is no longer possible. With these changes I decided to make `Reference` implement `Hash` which in tern required making `DataType` implement `Hash` as `Reference` holds a list of generics (Eg. `{ property: MyReference<String> }`, where the generic is the `DataType` returned from `<String as specta::Type>::reference()`). `DataType` never implemented `Hash` due to `DataType::Literal(LiteralType::f64(...))` which is not `Hash` due to `f64: !Hash`.

One unexpected advantage of this change is that because `HashSet<Reference>` hashes the entire `Reference` including the generics, `specta-serde` will process each generic being passed to a referenced type separately which is actually more correct than the previous implementation as for example if the generic is used in a flatten field, the value of the generic would affect whether the type should be rejected or not. This was an awesome thing to fall out of the refactor I didn't even know was a problem.

It's possible supporting const generics will require us to review this decision as a const `f64` might need to be put into the `DataType` enum but for now this is a massive improvement to what we had. I also wonder if because a const `f64` has to come from the compiler (not runtime) we can express it in a different form (maybe `&'static str`) which can be safely hashed as we don't need to support floating-point math on it. However I need to read more about Rust's rules of floating point numbers in const contexts to understand if this is safe or not.

### Opaque references

Sometimes you want to implement `Type` for a Rust-type which has an exporter-specific meaning. For example `Channel` in Tauri doesn't actually mean anything to the Swift exporter, it only means something to the Typescript exporter as it's aware of the Tauri JS runtime which has a Javascript class to represent a `Channel`.

With this I have build a system for opaque references (here is a real-world example for `specta_typescript::Any`):

```rs
pub struct Any<T = ()>(T);

pub(crate) static ANY_REFERENCE: Reference = Reference::opaque_from_sentinel({
    static SENTINEL: () = ();
    &SENTINEL
});

impl<T> Type for Any<T> {
    fn definition(_: &mut TypeCollection) -> DataType {
        // This just be `Reference::opaque()` but it *must* be cloned and identicial on each call.
        // You could have a `OnceLock<Reference>` which is simple but it would require the memory allocated by the `Reference::opaque()` call to exist for the lifetime of the program.
        // Using `Reference::opaque_from_sentinel` doesn't allocate a reference but is also a lot more error prone. Eg. using `const` instead of `static` will break it's invariants.

        DataType::Reference(ANY_REFERENCE.clone())
    }
}
```

Then in the Typescript exporter we do something like:
```rust
fn export_reference(reference: &Reference) -> String {
    // Note: This is a simplification of the real-world. We actually use "exporter references" to implement this (but they are explained in the next section).
    if reference == &ANY_REFERENCE {
        "any".to_string()
    } else {
        format!("{}", reference.name()) // This also handles generics, and more in the real-world implementation.
    }
}
```

In result this allows us to do something like the following:
```rust
#[derive(Type)]
pub struct Something {
    #[specta(type = specta_typescript::Any)]
    pub field: SomeNonSpectaType,
}
```

I am also thinking of moving Tauri Specta and TauRPC to use this for supporting `tauri::Channel` as the `TypeCollection` manipulation we used to do is no longer supported. This solution is much more robust as the exporters can detect unhandled opaque references and give useful errors instead of the manual manipulation causing internal panicking due to broken invariants of `TypeCollection`.

### Exporter references

In Tauri Specta and TauRPC's exporter code they express custom Typescript objects similar to the following:

```rust
format!("{{ some_property: {} }}", specta_typescript::primtives::export(...));
```

Which looks simple in this example but then they want to export Rust documentation comments, deprecated attributes which requires a JSDoc builder.

And then they want to handle cross-file imports for multi-file exporters, and more.

and very quickly your reimplementing half of `specta-typescript` in the downstream framework, but your custom implementation doesn't benefit from the rigor of Specta's tests and is a pain to maintain.

The core reason why these types are usually manually constructed in strings instead of being given to Specta is because they want to export things which can't be expressed by `DataType`. For example Tauri Specta exports something like:

```ts
export const commands = {
  my_command: (...) => TAURI_INVOKE("command", ...)
}
````

a closure and it's runtime code can't be expressed by `specta::DataType` because that would require being able to represent all Typescript syntax ðŸ˜….

So exporter references are the solution I came up with. They look like the following:

```rust
let ts = specta_typescript::Typescript::default();

let mut s = specta::datatype::Struct::named();
for command in commands {
    // Some logic to build up the closure here

    let mut field = specta::datatype::Field::new(self.define(format!("({arguments}) => {body}")).into());
    field.set_deprecated(command.deprecated().cloned());
    field.set_docs(command.docs().clone());
    s = s.field(command.name().to_lower_camel_case(), field);
}

println!("{}", specta_typescript::primitives::inline(self, cfg.types, &s.build())?);
```

The way this works is similar to opaque references where `Typescript` holds a `Vec<(Reference, Cow<'static, str>)>,` and then in `export_reference` we do something like:

```rust
fn export_reference(reference: &Reference) -> String {
    if let Some((_, typescript)) = ts.references.iter().find(|(re, _)| re.ref_eq(r)) {
        s.push_str(typescript);
        return Ok(());
    } else {
        format!("{}", reference.name()) // This also handles generics, and more in the real-world implementation.
    }
}
```

This results of this are:
 - Easier maintaince for TauRPC and Tauri Specta (once they adopt the new API)
 - More reliable due to a single shared implementation across Specta-based frameworks which can be well tested
 - Mostly-support for multi-file exporting without Tauri Specta and TauRPC needing to think about type imports
 - More consistent bindings format (Specta can have a consistent reasonable default for people who disable formatting on that file)
 - Implicit JSDoc support. Eg. `specta_typescript::Typescript` can be rewritten as `specta_typescript::JSDoc` and it should *just work*, no other changes (*unless the runtime injects custom code into the bindings file*)

## Drop `NamedType` and `Flatten`

Both of these were good ideas but i'm not sure they belong in core.

`NamedType` is a nice convience when doing type-map manipulation but I am trying to design newer API's to make that much harder because it breaks assumptions that Specta's core and exporters depend on. I also believe we can provide better ways to achieve the same sort of things (especially in related with the `Reference` overhaul). Closed by [#429](https://github.com/specta-rs/specta/pull/429)

`Flatten` was designed for compile-time validation of whether flattening is valid. Serde don't do this themselves and I think we have kinda figured out why. It's hard to properly tell in all scenarios and with the move to unbake Serde from Specta's core for better separation of concerns this feature is no longer worth it.

Both of these macros where also commonly forgotten when doing a custom `impl Type for T`, so removing them is nice to simplify the core and reduce bugs with Specta. They were commonly implemented incorrectly in Specta's own official crate implementations (ðŸ˜…) which isn't a great sign of a good API.

## Specta Serde is reborn

[#430](https://github.com/specta-rs/specta/pull/430) - incomplete but getting very close

It became clear very early in Specta's development that it can be a very powerful general introspection tool. This is what brought about support for more langauges than just Typescript and it has even be intended to extend to data formats. Although most of the ecosystem use [Serde](https://serde.rs), it's not the only possible option and we had started work on trying to break more of the Serde support out of the Specta core. This is where `specta-serde` started but i've always been hazzy on exactly how this idea was going to be achieved.

This This PR does a massive refactor which moves the handling of Serde attributes from the Specta macro to the runtime `specta-serde` crate opening up the ability for other formats to implement their own userspace support.

The main concept is that when you pass a type with attributes all of them are visible in the `TokenStream` Specta's macros see. For example:

```bash
#[derive(Type, MyMacro)]
pub struct Testing {
    #[my_attribute(something = "abc")]
    pub testing: String,
}
```

With the new Specta system when we create `DataType::Struct` we also include a lowered version of the raw `TokenStream` passed to `my_attribute` on the `Field`. The same is done for enum variant and contrainer attributes. Then the runtime code in `specta-serde`/any userspace implementation can parse the raw-attributes in whatever way it wants and it can tranform the `DataType` before it's given to `specta-typescript` to implement tagging, renames and more.

Supporting multiple formats is cool but how is this generally useful? This enables per-phase attributes.

For example `specta_serde` can expose:
```rust
// This is not an actual API but it shows the idea better and the final API is undecided.

pub fn transform_for_serialize(dt: DataType) -> DataType;

pub fn transform_for_deserialize(dt: DataType) -> DataType;

pub fn transform_for_both(dt: DataType) -> DataType;
```

When paired with Specta Typescript you can export your type and account for attributes which are differently by Serde between `Serialize` and `Deserialize`. In practice this feature is a bit advanced for an average user but my vision is that TauRPC and Tauri Specta will just handle this internally and end-users don't even need to know about it.

<Callout>This PR implements the Specta core support for per-phase attributes but doesn't actually expose the data from the Serde crate at the moment as it's unclear what the correct API is. <br /> <br /> One major concern I have is that if a type is used by the user for both serialization and deserialization it will need to be exported twice in the bindings file which I could see users disliking. I have some ideas to fix this but for now the Specta core support is the main focus, I can iterate on the high-level APIs later.</Callout>

This PR also aims to implement many missing Serde attributes.

#258 & #232 & #332 & #229 & #328 & #332 & #114 & #229 & #402 & #395 & #132 & #130 & #22

This PR should close the following issues:
 - [#258](https://github.com/specta-rs/specta/issues/258)
 - [#232](https://github.com/specta-rs/specta/issues/232)
 - [#332](https://github.com/specta-rs/specta/issues/332)
 - [#229](https://github.com/specta-rs/specta/issues/229)
 - [#328](https://github.com/specta-rs/specta/issues/328)
 - [#114](https://github.com/specta-rs/specta/issues/114)
 - [#402](https://github.com/specta-rs/specta/issues/402)
 - [#395](https://github.com/specta-rs/specta/issues/395)
 - [#132](https://github.com/specta-rs/specta/issues/132)
 - [#130](https://github.com/specta-rs/specta/issues/130)
 - [#22](https://github.com/specta-rs/specta/issues/22)

It also makes progress towards another 5-or-so more but they require more specific work.

One major thing to note with this change is that previously the following would compile:
```rust
#[derive(Specta)]
#[serde(untagged)] // Any `serde` attributes.
enum Testing { ... }
```

but with the new system `serde` attributes are treated as unknown by Specta so the user will be asked by Rust to include `serde::Serialize`. This is great as in a real-world senario if your using a Serde attribute, you will need to Serde runtime on your type.

Another example of this is that previously:
```rust
#[derive(Specta)]
#[specta(untagged)] // Any `serde`-format attributes passed to `specta`
enum Testing { ... }
```

would work as we parsed the arguments from `specta` and `serde` attributes into the same arguments struct. This will fail to compile as now only Specta-specific attributes can be pased to `#[specta(...)]`. This is great as in practice `#[specta(untagged)]` is not processed by `serde::{Serialize, Deserialize}` so this code would have been broken.

Sadly as this PR is a large refactor and new paradigm, I expect some regressions in the short-term but unit testing will help to iron these out. I am likely going to try and upgrade some real-world codebases to get a better idea of the impact on regular library users to see if a codemod or better guidance can be provided.

## JSDoc rework

This is required to upgrade Tauri Specta as it heavily depends on it. JSDoc is also used for the Typescript exporting of the deprecated attribute and comments. The support for exporting doc comments and deprecated attributes on struct fields and enum variants with Typescript is also a little buggy in `main` due to this.

The JSDoc API is still not complete but it's reusing much more of the Typescript exporters code and is now exposed as `specta_typescript::JSDoc` instead of `specta_jsdoc::JSDoc` as it is not worth it when JSDoc needs so many of the Typescript exporters internals (it's literally a `pub struct JSDoc(crate::Typescript);` where `Typescript` has a hidden `jsdoc: bool` field for slightly adjusting the output).

## Incomplete

Things i've started work on but been unable to finish due to technical constraints. I will come back to these once i've had some more time to work/think.

### TauRPC upgrade

I have started upgrading TauRPC to the `main`. This is a little bit of work with some of the breaking changes and with knowledge of some future ones I am going to make i've been trying to take them into account.

With the new "framework references" feature I think we can also simplify the exporter code a heap but this is going to be something for once the idea is proven out in Tauri Specta as I can afford to ship beta Specta APIs inside Tauri Specta as it's me who maintains it.

[#58](https://github.com/MatsDK/TauRPC/pull/58)

### Drop `#[specta::specta]` from core

The whole function handling system is too tied to Tauri Specta, and there has been discussion in the Tauri working group about ideas of a non-macro command system. On top of that it's always been an idea for me to try and hide `#[specta::specta]` under the `#[tauri::command]` macro as having both is bad DX.

I have done up a PR for removing this stuff but it would be a breaking change to the code that is within the Tauri crate so this is going to need to be approached with caution.

Also with the introduction of `Reference::opaque` I also want to change the `Type` implementation for `Channel` which is going to be rough.

This work is generally skewed towards Tauri Specta as TauRPC doesn't use the function macros from my knowledge (it only uses the `tauri::Channel` implementation) but these changes are *major* blockers for the next Specta release going forward.

I came up with a prototype for the minimal changes to Tauri to allow us to drop `specta::specta` from Tauri Specta [here](https://github.com/oscartbeaumont/tauri/commit/5719486dc97a17f90e94d018505eaa31677960c5). These need some more cleanup before I will do an upstream PR but it's promising. I also chatted with Lucas from the Tauri core-team and he seemed to be able to get behind it but i'm not sure if everyone will be thrilled by these changes as they are basically Tauri Specta-specific code in the Tauri code (although a very minimal amount).

This also closes function system related issues as not planned:
 - [#379](https://github.com/specta-rs/specta/issues/379)
 - [#213](https://github.com/specta-rs/specta/issues/213) - leaving open until we have a solution with the next version of the function integration.

[#432](https://github.com/specta-rs/specta/pull/432)

## Phase 2

Blocking Release:
 - Tauri-stuff sorted. This is a major blocker for the next release.
 - https://github.com/specta-rs/specta/issues/356
 - Cleanup default formatting of bindings (before we finish overhaulling testing cause it'll break all of them)
 - Overhaul testing as the runtime-attribute refactor has broken a lot ðŸ˜…
 - Tauri Specta upgraded
 - TauRPC upgraded


Would be nice:
 - Upgrade a couple of real-world codebases because I suspect we are going to find regressions with this massive core work.
 - Nauanced types prototype. I did a Specta PR [#419](https://github.com/specta-rs/specta/pull/419) but most of the work for this will be in Tauri Specta/TauRPC and also I think we will need changes to Tauri for BigInt support.
 - Figure out the specifics of per-phase handling in Tauri Specta/TauRPC with `specta-serde` -> Main issue is around duplicated types, maybe we export `{TypeName}_Serialize` & `{TypeName}_Deserialize` and then `export type {TypeName} = {TypeName}_Serialize | {TypeName}_Deserialize;`.
 - Figure out how to make `alias` properly exported to Typescript as a descriminated union. This is a bit of a remaining question in how `specta-serde` needs to work.
 - `impl Type for Result<T, E>` (likely blocked on removal of `#[specta::specta]`)
 - Figure out how `MaybeUndefined` could be represented with Specta/`DataType`.
 - Documentation overhaul (including documentation for all-possible attributes that we support)
 - Release next `specta-rc.23`

Potentially look at upstreaming [this](https://github.com/fltsci/plugins-workspace/tree/add-specta-to-updater) into Tauri Plugins repo as they do already have Specta in that repo.
